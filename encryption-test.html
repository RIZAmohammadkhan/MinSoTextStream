<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DM Encryption Test</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .section { border: 1px solid #ccc; margin: 10px 0; padding: 15px; }
        button { padding: 10px 15px; margin: 5px; }
        textarea { width: 100%; height: 100px; margin: 5px 0; }
        .key-display { font-family: monospace; word-break: break-all; background: #f5f5f5; padding: 10px; }
    </style>
</head>
<body>
    <h1>DM Encryption Testing</h1>
    
    <div class="section">
        <h3>Step 1: Generate Key Pairs</h3>
        <button onclick="generateKeyPairs()">Generate Key Pairs for User A & B</button>
        <div id="keyPairs"></div>
    </div>
    
    <div class="section">
        <h3>Step 2: Test Message Encryption</h3>
        <textarea id="messageInput" placeholder="Enter a message to encrypt...">Hello! This is a test encrypted message üîí</textarea>
        <button onclick="encryptMessage()">Encrypt Message (A to B)</button>
        <div id="encryptionResult"></div>
    </div>
    
    <div class="section">
        <h3>Step 3: Test Message Decryption</h3>
        <button onclick="decryptMessage()">Decrypt Message (B receives)</button>
        <div id="decryptionResult"></div>
    </div>

    <script>
        let userAKeys = null;
        let userBKeys = null;
        let encryptedMessageData = null;

        // Utility functions
        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            bytes.forEach(byte => binary += String.fromCharCode(byte));
            return btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        async function generateKeyPairs() {
            try {
                // Generate User A keys
                const keyPairA = await window.crypto.subtle.generateKey(
                    {
                        name: 'RSA-OAEP',
                        modulusLength: 2048,
                        publicExponent: new Uint8Array([1, 0, 1]),
                        hash: 'SHA-256'
                    },
                    true,
                    ['encrypt', 'decrypt']
                );

                const publicKeyA = await window.crypto.subtle.exportKey('spki', keyPairA.publicKey);
                const privateKeyA = await window.crypto.subtle.exportKey('pkcs8', keyPairA.privateKey);

                userAKeys = {
                    publicKey: arrayBufferToBase64(publicKeyA),
                    privateKey: arrayBufferToBase64(privateKeyA)
                };

                // Generate User B keys
                const keyPairB = await window.crypto.subtle.generateKey(
                    {
                        name: 'RSA-OAEP',
                        modulusLength: 2048,
                        publicExponent: new Uint8Array([1, 0, 1]),
                        hash: 'SHA-256'
                    },
                    true,
                    ['encrypt', 'decrypt']
                );

                const publicKeyB = await window.crypto.subtle.exportKey('spki', keyPairB.publicKey);
                const privateKeyB = await window.crypto.subtle.exportKey('pkcs8', keyPairB.privateKey);

                userBKeys = {
                    publicKey: arrayBufferToBase64(publicKeyB),
                    privateKey: arrayBufferToBase64(privateKeyB)
                };

                document.getElementById('keyPairs').innerHTML = `
                    <h4>User A Public Key:</h4>
                    <div class="key-display">${userAKeys.publicKey.substring(0, 100)}...</div>
                    <h4>User B Public Key:</h4>
                    <div class="key-display">${userBKeys.publicKey.substring(0, 100)}...</div>
                    <p style="color: green;">‚úÖ Key pairs generated successfully!</p>
                `;
            } catch (error) {
                console.error('Key generation failed:', error);
                document.getElementById('keyPairs').innerHTML = `<p style="color: red;">‚ùå Key generation failed: ${error.message}</p>`;
            }
        }

        async function encryptMessage() {
            if (!userAKeys || !userBKeys) {
                alert('Please generate key pairs first!');
                return;
            }

            const message = document.getElementById('messageInput').value;
            if (!message) {
                alert('Please enter a message!');
                return;
            }

            try {
                // Generate AES key
                const aesKey = await window.crypto.subtle.generateKey(
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['encrypt', 'decrypt']
                );

                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                
                // Encrypt content with AES
                const encoder = new TextEncoder();
                const encryptedContent = await window.crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv },
                    aesKey,
                    encoder.encode(message)
                );

                // Import User B's public key
                const publicKeyBuffer = base64ToArrayBuffer(userBKeys.publicKey);
                const publicKey = await window.crypto.subtle.importKey(
                    'spki',
                    publicKeyBuffer,
                    { name: 'RSA-OAEP', hash: 'SHA-256' },
                    false,
                    ['encrypt']
                );

                // Export AES key and encrypt it with RSA
                const aesKeyBuffer = await window.crypto.subtle.exportKey('raw', aesKey);
                const encryptedAesKey = await window.crypto.subtle.encrypt(
                    { name: 'RSA-OAEP' },
                    publicKey,
                    aesKeyBuffer
                );

                encryptedMessageData = {
                    encryptedContent: arrayBufferToBase64(encryptedContent),
                    encryptedKey: arrayBufferToBase64(encryptedAesKey),
                    iv: arrayBufferToBase64(iv.buffer)
                };

                document.getElementById('encryptionResult').innerHTML = `
                    <h4>Encrypted Message Data:</h4>
                    <p><strong>Content:</strong> ${encryptedMessageData.encryptedContent.substring(0, 50)}...</p>
                    <p><strong>Key:</strong> ${encryptedMessageData.encryptedKey.substring(0, 50)}...</p>
                    <p><strong>IV:</strong> ${encryptedMessageData.iv}</p>
                    <p style="color: green;">‚úÖ Message encrypted successfully!</p>
                `;
            } catch (error) {
                console.error('Encryption failed:', error);
                document.getElementById('encryptionResult').innerHTML = `<p style="color: red;">‚ùå Encryption failed: ${error.message}</p>`;
            }
        }

        async function decryptMessage() {
            if (!encryptedMessageData || !userBKeys) {
                alert('Please encrypt a message first!');
                return;
            }

            try {
                // Import User B's private key
                const privateKeyBuffer = base64ToArrayBuffer(userBKeys.privateKey);
                const privateKey = await window.crypto.subtle.importKey(
                    'pkcs8',
                    privateKeyBuffer,
                    { name: 'RSA-OAEP', hash: 'SHA-256' },
                    false,
                    ['decrypt']
                );

                // Decrypt AES key
                const encryptedKeyBuffer = base64ToArrayBuffer(encryptedMessageData.encryptedKey);
                const aesKeyBuffer = await window.crypto.subtle.decrypt(
                    { name: 'RSA-OAEP' },
                    privateKey,
                    encryptedKeyBuffer
                );

                // Import AES key
                const aesKey = await window.crypto.subtle.importKey(
                    'raw',
                    aesKeyBuffer,
                    { name: 'AES-GCM' },
                    false,
                    ['decrypt']
                );

                // Decrypt content
                const ivBuffer = base64ToArrayBuffer(encryptedMessageData.iv);
                const encryptedContentBuffer = base64ToArrayBuffer(encryptedMessageData.encryptedContent);
                const decryptedBuffer = await window.crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: ivBuffer },
                    aesKey,
                    encryptedContentBuffer
                );

                const decoder = new TextDecoder();
                const decryptedMessage = decoder.decode(decryptedBuffer);

                document.getElementById('decryptionResult').innerHTML = `
                    <h4>Decrypted Message:</h4>
                    <div style="background: #e8f5e8; padding: 15px; border-radius: 5px; font-size: 18px;">
                        "${decryptedMessage}"
                    </div>
                    <p style="color: green;">‚úÖ Message decrypted successfully!</p>
                `;
            } catch (error) {
                console.error('Decryption failed:', error);
                document.getElementById('decryptionResult').innerHTML = `<p style="color: red;">‚ùå Decryption failed: ${error.message}</p>`;
            }
        }
    </script>
</body>
</html>
